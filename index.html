<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Copy Text Buttons</title>
    <style>
        button {
            margin: 5px;
        }

        body {
            /* background-color: #1F1D36; */
            background-image: url("https://raw.githubusercontent.com/hel0118/sukuna/main/jujutsu-kaisen-sukuna-uhdpaper.com-4K-7.3063.jpg");
            background-size: 100% auto;
            /* Center the background image */
            font-family: Arial, sans-serif;
            text-align: center;
            transition: 1s ease-in-out;
        }

        @media only screen and (max-width: 600px) {

            /* Adjust properties for screens with a maximum width of 600px (adjust as needed) */
            body {
                background-image: url("https://raw.githubusercontent.com/hel0118/sukuna/main/real_esrgan_Zoro.jpg");
                background-size: 135%;
                /* Auto size for smaller screens */
                background-position: top;
                /* Center the background image, crop from top */
            }
        }


        button {
            color: #ccc;
            margin: 10px;
            padding: 10px;
            font-size: 16px;
            background-color: #dddddd00;
            /* Light gray button background */
            border: 1px solid #aaa;
            /* Dark gray border */
            cursor: pointer;
            transition: 500ms ease-in-out;
        }

        button:hover {
            color: darkslategrey;
            background-color: #ccc;
            /* Slightly darker background on hover */
        }
    </style>
</head>

<body>

    <button onclick="copyText(text1)">Linear Neural Network(Binary and Bipolar sigmoidal)</button>
    <button onclick="copyText(text2)">SVM</button>
    <button onclick="copyText(text3)">Decision Tree</button>
    <button onclick="copyText(text4)">KNN-K Nearest Neighbour</button>
    <button onclick="copyText(text5)">KMeans</button>
    <button onclick="copyText(GaussianNB)">Gaussian Naive Bayes</button>
    <button onclick="copyText(MultinomialNB)">Multinomial Naive Bayes</button>
    <button onclick="copyText(CategoricalNB)">Categorical Naive Bayes</button>
    <button onclick="copyText(text9)">McCulloch Pitts</button>
    <p id="copiedMsg"></p>
    <script>
        var text1 = `
x=float(input("Enter value of x:"))
w=float(input("Enter value of w:"))
b=float(input("Enter value of b:"))
net = int(w*x+b)
if(net<0):
    out=0
elif((net>=0)&(net<=1)):
    out=net
else:
    out=1
print("net=",net)
print("output=",out)


#number of elements as input
n = int(input("Enter number of elements:"))

print("Enter the inputs:")
inputs= [] #creating an empty list for inputs
#iternating till the range
for i in range(0,n):
    ele = float(input())
    inputs.append(ele) #adding the element
print(inputs)


print("Enter the weights:")
weights= [] #creating an empty list for inputs
#iternating till the range
for i in range(0,n):
    ele = float(input())
    weights.append(ele) #adding the element
print(weights)


print("The net input can be calculated as Yin = x1w1 + x2w2 + x3w3")
# In[4]
Yin= []
for i in range(0,n):
    Yin.append(inputs[i]*weights[i])
sum = round(sum(Yin),3)
print(sum)

if(sum<0):
    out=0
elif(sum>=0&sum<=1):
    out=net
else:
    out=1
print(out)`;

        var text2 = `
import pandas as pd
import numpy as  np
import seaborn as sns
from sklearn.model_selection import train_test_split,cross_val_score,cross_val_predict
from sklearn import svm
from sklearn.svm import SVC,LinearSVC
from sklearn.metrics import confusion_matrix,accuracy_score,classification_report

pd.set_option('display.max_rows',1000) #optional
pd.set_option('display.max_columns',1000) #optional
pd.set_option('display.width',1000) #optional

data = pd.read_csv('diabetes.csv')

data.head(5)

data.tail(5)

data.shape

data.describe()

x = data.drop('Outcome',axis=1)
y = data['Outcome']

xtrain = x.iloc[:600]
xtest = x.iloc[600:]
ytrain = y[:600]
ytest = y[600:]

print("xtrain Shape: ",xtrain.shape)
print("xtest Shape: ",xtest.shape)
print("ytrain Shape: ",ytrain.shape)
print("ytest Shape: ",ytest.shape)

svcobj = SVC(kernel="linear").fit(xtrain,ytrain)

svcobj

svcobj.C

ypred = svcobj.predict(xtest)

cm = confusion_matrix(ytest,ypred)

print(cm)
`;
        var text3 = `
import pandas as pd
from sklearn.preprocessing import LabelEncoder
from sklearn import tree

dataTable = pd.read_csv("PlayTennis.csv")
dataTable

dataTable.shape

dataTable.describe()

dataTable.dtypes

dataTable.head(5)

dataTable.tail(5)

dataTable.columns

Le = LabelEncoder()
dataTable['Outlook'] = Le.fit_transform(dataTable ['Outlook'])
dataTable['Temperature'] = Le.fit_transform (dataTable ['Temperature'])
dataTable['Humidity'] = Le.fit_transform(dataTable['Humidity'])
dataTable['Wind'] = Le.fit_transform (dataTable ['Wind'])
dataTable['Play Tennis'] = Le.fit_transform (dataTable['Play Tennis'])
dataTable

y = dataTable['Play Tennis']
x = dataTable.drop(['Play Tennis'], axis=1)
x.dtypes

clf = tree.DecisionTreeClassifier(criterion = 'entropy')
clf = clf.fit(x,y)
tree.plot_tree(clf)`;

        var text4 = `
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix
from sklearn.metrics import roc_curve
from sklearn.metrics import classification_report

df = pd.read_csv("diabetes.csv")
df.head()

x = df.drop('Outcome',axis=1).values
y = df['Outcome'].values

x_train,x_test,y_train,y_test = train_test_split(x,y,test_size = 0.4,random_state = 42)

neighbors = np.arange(1,9)
train_accuracy = np.empty(len(neighbors))
test_accuracy = np.empty(len(neighbors))

for i,k in enumerate(neighbors):
  knn = KNeighborsClassifier(n_neighbors= k)
  knn.fit(x_train,y_train)
  train_accuracy[i] = knn.score(x_train,y_train)
  test_accuracy[i] =    knn.score(x_test,y_test)

plt.title('k-NN Varying number of neighbors')
plt.plot(neighbors,test_accuracy,label='Testing Accuracy')
plt.plot(neighbors,train_accuracy,label='Training Accuracy')
plt.legend()
plt.xlabel('Number of neighbors')
plt.ylabel('Accuracy')
plt.show()

knn= KNeighborsClassifier(n_neighbors=7)

knn.fit(x_train,y_train)
KNeighborsClassifier(n_neighbors=7)

knn.score(x_test,y_test)

y_pred = knn.predict(x_test)

confusion_matrix(y_test,y_pred)

print(classification_report(y_test,y_pred))

y_pred_proba = knn.predict_proba (x_test)[:,1]

fpr, tpr, thresholds = roc_curve (y_test, y_pred_proba)

plt.plot([0,1],[0,1], 'k--')
plt.plot(fpr, tpr, label='Knn')
plt.xlabel('fpr')
plt.ylabel('tpr')
plt.title('Knn(n_neighbors=7) ROC curve')
plt.show()

from sklearn.metrics import roc_auc_score
roc_auc_score
(y_test,y_pred_proba)

from sklearn.model_selection import GridSearchCV
param_grid = {'n_neighbors': np.arange(1,50)}

knn = KNeighborsClassifier()
knn_cv= GridSearchCV (knn, param_grid,cv=5)
knn_cv.fit(x,y)

knn_cv.best_params_

knn_cv.best_score_`;

        var text5 = `
# **Kmean New**

import pandas as pd
from sklearn.cluster import KMeans
from sklearn.model_selection import train_test_split
from sklearn import preprocessing
import seaborn as sns
from sklearn.metrics import silhouette_score
import warnings

#select only longitude,latitude and median house value
homeData = pd.read_csv("/content/housing.csv", usecols = ['longitude','latitude','median_house_value'])
homeData.head(5)

#display the map with the help of longitude and latitude
sns.scatterplot(homeData,x = 'longitude',y = 'latitude',hue = 'median_house_value')

Xtrain,Xtest,Ytrain,Ytest = train_test_split(homeData[['longitude','latitude']],homeData[['median_house_value']],test_size=0.33,random_state=0)
#Xtrain,Xtest,Ytrain,Ytest = train_test_split(homeData[['longitude','latitude','median_house_value']],test_size=0.33,random_state=42)

#normalise the data i.e avoiding outliers
XtrainNorm = preprocessing.normalize(Xtrain)
XtestNorm = preprocessing.normalize(Xtest)

#making the clusters of three
kmeans = KMeans(n_clusters= 3 ,random_state = 0)
kmeans.fit(X_train_norm)

sns.scatterplot(Xtrain,x = 'longitude',y = 'latitude',hue = kmeans.labels_)

sns.boxplot(x = kmeans.labels_,y = Ytrain['median_house_value'])

silScore = silhouette_score(XtrainNorm,kmeans.labels_,metric = 'euclidean')

K = range(2,8)
fits = []
score = []

for k in K:
    #train the model for current value of k on training data
    model = KMeans(n_clusters = k, random_state = 0).fit(XtrainNorm)

    #append the model to fits
    fits.append(model)

    #append the silhouette score to scores
    score.append(silhouette_score(XtrainNorm, model.labels_, metric='euclidean'))

sns.scatterplot(data = X_train, x='longitude',y='latitude', hue = fits[5].labels_)

sns.scatterplot(data = Xtrain, x='longitude',y='latitude', hue = fits[2].labels_)

sns.lineplot(x=K,y=score)
`;

        var GaussianNB = `
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import GaussianNB
from sklearn.metrics import accuracy_score,classification_report
from sklearn.metrics import confusion_matrix,precision_score,recall_score,f1_score

df = pd.read_csv("/content/iris.csv")
df.head(5)
df.describe()
df.info()
df.dtypes
df.columns

#Selecting columns for input i.e 'sepal_length', 'sepal_width', 'petal_length', 'petal_width'
X = df.iloc[:,[0,1,2,3]].values

#Selecting columns for output i.e 'species'
Y = df.iloc[:, 4].values

#X is input data
#Y is Target
#Splitting the data in traioning data and testing data for algorithm
xTrain,xTest,yTrain,yTest = train_test_split(X,Y,test_size = 0.2,random_state = 42)

#Storing model in a variable
GB = GaussianNB()

#Training the model with split training data
GB.fit(xTrain,yTrain)

#Predicting Model
yPred = GB.predict(xTest)

#Predicting the species with user input
out = GB.predict([[5.9,3.0,5.1,1.8]])
print(out)

#Confusion Matrix
print(confusion_matrix(yTest,yPred))

#accuracy score
print(accuracy_score(yTest,yPred))

#classification Reprt
print(classification_report(yTest,yPred))`;

        var MultinomialNB = `
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score,classification_report
from sklearn.metrics import confusion_matrix,precision_score,recall_score,f1_score
from sklearn.naive_bayes import MultinomialNB

df = pd.read_csv("/content/iris.csv")
df.head(5)
df.describe()
df.info()
df.dtypes
df.columns

#Selecting columns for input i.e 'sepal_length', 'sepal_width', 'petal_length', 'petal_width'
X = df.iloc[:,[0,1,2,3]].values

#Selecting columns for output i.e 'species'
Y = df.iloc[:, 4].values

#X is input data
#Y is Target
#Splitting the data in traioning data and testing data for algorithm
xTrain,xTest,yTrain,yTest = train_test_split(X,Y,test_size = 0.2,random_state = 42)

#Storing model in a variable
MB = MultinomialNB()

#Training the model with split training data
MB.fit(xTrain,yTrain)

#Predicting Model
yPred = MB.predict(xTest)

#Predicting the species with user input
out = MB.predict([[5.9,3.0,5.1,1.8]])
print(out)

#Confusion Matrix
print(confusion_matrix(yTest,yPred))

#accuracy score
print(accuracy_score(yTest,yPred))

#classification Reprt
print(classification_report(yTest,yPred))`;

        var CategoricalNB = `
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score,classification_report
from sklearn.metrics import confusion_matrix,precision_score,recall_score,f1_score
from sklearn.naive_bayes import CategoricalNB

df = pd.read_csv("/content/iris.csv")
df.head(5)
df.describe()
df.info()
df.dtypes
df.columns

#Selecting columns for input i.e 'sepal_length', 'sepal_width', 'petal_length', 'petal_width'
X = df.iloc[:,[0,1,2,3]].values

#Selecting columns for output i.e 'species'
Y = df.iloc[:, 4].values

#X is input data
#Y is Target
#Splitting the data in traioning data and testing data for algorithm
xTrain,xTest,yTrain,yTest = train_test_split(X,Y,test_size = 0.2,random_state = 42)

#Storing model in a variable
CB = CategoricalNB()

#Training the model with split training data
CB.fit(xTrain,yTrain)

#Predicting Model
yPred = CB.predict(xTest)

#Predicting the species with user input
out = CB.predict([[5.9,3.0,5.1,1.8]])
print(out)

#Confusion Matrix
print(confusion_matrix(yTest,yPred))

#accuracy score
print(accuracy_score(yTest,yPred))

#classification Reprt
print(classification_report(yTest,yPred))
`;

        var text9 = `
import numpy
#We Will Take the no of values/inputs
num_ip = int(input("Enter the number of inputs:"))
# set the weights with value 1
w1= 1
w2= 1
print("For the",num_ip,"inputs calculate the net input using yin= x1w1 + x2w2")
x1= []
x2= []

for j in range(0,num_ip):
    e1e1 = int(input("x1 = "))
    e1e2 = int(input("x2 = "))
    x1.append(e1e1)
    x2.append(e1e2)
print("x1 = ",x1)
print("x2 = ",x2)

n = x1 * w1
m = x2 * w2
Yin = []
for i in range(0,num_ip):
    Yin.append(n[i] + m[i])
print("Yin =", Yin)

#Assume one weight as excitatory and the other as inhibitory, i.e,
Yin = []
for i in range(0,num_ip):
    Yin.append(n[i] - m[i])
print("After assuming one weight as excitatory and the other as inhibitory Yin=", Yin)

#from the calculated net inputs, now it is possible yo fire the neuron for input(1,-1)
# only by fixing a threshold of 1, i.e., 0 > 1 for Y unit
# Thus, w1 = 1, w2= -1, 0>=15
Y=[]
for i in range(0,num_ip):
    if(Yin[i]>=1):
        ele=1
        Y.append(ele)
    if(Yin[i]<1):
        ele=0
        Y.append(ele)
print("Y=",Y)
`;
        function copyText(text) {
            navigator.clipboard.writeText(text).then(function () {
                document.getElementById('copiedMsg').innerHTML = "Text Copied"
            }).catch(function (err) {
                console.error('Unable to copy text', err);
            });
        }
    </script>

</body>

</html>
